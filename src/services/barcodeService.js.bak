const Jimp = require('jimp');
const Quagga = require('@ericblade/quagga2');
const fs = require('fs');
const path = require('path');

class BarcodeService {
  static async decode(imageBuffer) {
    try {
      // Primeiro tenta com BarcodeDetector (mais moderno)
      try {
        const detector = new BarcodeDetector({ formats: ['ean_13'] });
        const image = await Jimp.read(imageBuffer);
        const imageData = {
          data: new Uint8ClampedArray(image.bitmap.data),
          width: image.bitmap.width,
          height: image.bitmap.height
        };
        
        const barcodes = await detector.detect(imageData);
        if (barcodes && barcodes.length > 0) {
          return barcodes[0].rawValue;
        }
      } catch (e) {
        console.log("BarcodeDetector falhou, tentando com Quagga.");
      }
      
      // Para EAN13, vamos tentar com processamento de imagem otimizado
      
      // Cria um arquivo temporário para o Quagga
      const tmpFilePath = path.join(__dirname, '../../temp', `barcode-${Date.now()}.jpg`);
      
      // Certifique-se de que o diretório temp existe
      if (!fs.existsSync(path.join(__dirname, '../../temp'))) {
        fs.mkdirSync(path.join(__dirname, '../../temp'), { recursive: true });
      }
      
      // Pré-processamento da imagem para melhorar reconhecimento
      const processedImageBuffer = await this.preprocessImage(imageBuffer);
      fs.writeFileSync(tmpFilePath, processedImageBuffer);
      
      // Tenta ler com diferentes configurações para aumentar a chance de sucesso
      const result = await this.attemptMultipleDecodes(tmpFilePath);
      
      // Remove o arquivo temporário
      try {
        fs.unlinkSync(tmpFilePath);
      } catch (e) {
        console.error('Erro ao remover arquivo temporário:', e);
      }
      
      return result;
    } catch (err) {
      console.error('Erro ao processar imagem:', err);
      return null;
    }
  }
  
  static async preprocessImage(imageBuffer) {
    try {
      const image = await Jimp.read(imageBuffer);
      
      // Aplicar processamento otimizado para códigos de barras EAN13
      image
        .grayscale()           // Converte para escala de cinza
        .contrast(0.3)         // Aumenta o contraste
        .brightness(0.1)       // Ajusta o brilho
        .normalize();          // Normaliza os valores
      
      // Redimensiona se a imagem for muito grande ou muito pequena
      if (image.bitmap.width > 1000 || image.bitmap.height > 1000) {
        image.resize(800, Jimp.AUTO);
      } else if (image.bitmap.width < 300 || image.bitmap.height < 300) {
        image.resize(600, Jimp.AUTO);
      }
      
      return await image.getBufferAsync(Jimp.MIME_JPEG);
    } catch (error) {
      console.error('Erro ao pré-processar imagem:', error);
      // Se falhar o processamento, retorna o buffer original
      return imageBuffer;
    }
  }
  
  static async attemptMultipleDecodes(filePath) {
    // Configurações diferentes para aumentar a chance de sucesso
    const configurations = [
      {
        readers: ['ean_reader'],
        locator: { patchSize: "medium" }
      },
      {
        readers: ['ean_reader', 'ean_8_reader', 'ean_13_reader', 'upc_reader', 'upc_e_reader'],
        locator: { patchSize: "large" }
      },
      {
        readers: ['code_128_reader', 'code_39_reader', 'ean_reader'],
        locator: { patchSize: "small" }
      }
    ];
    
    for (const config of configurations) {
      try {
        const result = await this.decodeWithConfig(filePath, config);
        if (result) return result;
      } catch (err) {
        console.log(`Tentativa falhou com configuração:`, config);
      }
    }
    
    return null;
  }
  
  static decodeWithConfig(filePath, config) {
    return new Promise((resolve) => {
      Quagga.decodeSingle({
        src: filePath,
        numOfWorkers: 0,
        inputStream: {
          size: 1200 // Aumentar tamanho para melhorar detecção
        },
        frequency: 10, // Aumentar frequência de varredura
        decoder: {
          readers: config.readers,
          multiple: false, // Garantir leitura única mais precisa
        },
        locate: true,
        locator: config.locator,
        debug: {
          showCanvas: false,
          showPatches: false,
          showFoundPatches: false,
          showSkeleton: false,
          showLabels: false,
          showPatchLabels: false,
          showRemainingPatchLabels: false,
        },
      }, function(result) {
        if (result && result.codeResult) {
          resolve(result.codeResult.code);
        } else {
          resolve(null);
        }
      });
    });
  }
}

module.exports = { BarcodeService };
